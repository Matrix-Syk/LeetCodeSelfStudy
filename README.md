2.PostProcessor:后置处理器;增强器;

当我们将配置文件或者注解扫描成beandefinition后,属性并没有被实例化都是些占位符,beanfactorypostprocessor接口中postprocessorbeanfactory的负责将这些占位符替换为实际的值,bean对象就可以实例化了

3.BeanFactory与ApplicationContext的区别?

两者都是Spring的容器,BeanFactory是所有容器的根接口,ApplicationContext继承了HierarchicalBeanFactory,HierarchicalBeanFactory继承了BeanFatory;

BeanFactory采用的是延迟加载的方式,只有第一次使用的时候才会被创建,这样虽然提升了效率但是也很难发现配置错误

ApplicationContext则是在容器启动的时候一次性创建所有的bean,优点就是在使用的时候效率更高,但是也更占用空间,应用庞大时启动较慢.它还可以为Bean配置lazy-init=true来让Bean延迟实例化 

BeanFactory通常以编程的方式被创建，ApplicationContext还能以声明的方式创建，如使用ContextLoader。 

BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。 

4.Bean的生命周期

bean的实例化

	通过读取beandefinition获取bean配置信息,将bedifinition中的配置信息的beanName放入一个arrayList,然后遍历创建对象,判断是否为抽象,单例,懒加载.普通的bean就直接创建对象.(getbean)

	通过反射的方式创建对象,在堆内存中开辟空间(反射创建对象,createBeanInstance)

	属性赋值

		给自定义属性赋值(populateBean);

		给容器对象属性赋值(检查是否实现awre接口,invokeAwareMethods)

	判断bean对象是否需要增强操作

		执行前置处理方法(BeanPostProcessor)

		初始化方法(invokeinitMethods→判断当前bean是否实现了InitilizingBean接口,然后调用afterPropertiesset)

		执行后置处理方法(BeanPostProcessor)

	对象使用

	对象销毁

5.循环依赖

默认情况下bean对象都是单例的,当两个或者以上对象之间互相引用,且达成闭环的时候就形成了循环依赖.

spring的三级缓存?

	private final Map<String, Object> singletonObjects = new ConcurrentHashMap<>(256); //一级缓存

	private final Map<String, Object> earlySingletonObjects = new ConcurrentHashMap<>(16); // 二级缓存

	private final Map<String, ObjectFactory<?>> singletonFactories = new HashMap<>(16); // 三级缓存

	除了类型和容量不同,重要的是泛型不同.

spring如何解决?

三级缓存和提前暴露对象   

解决的思路是依赖于对象的实例化(创建对象)和初始化(属性赋值)是可以分开的.

创建对象过程中的方法:

getBean→doGetBean→createBean→doCreateBean→ createBeanInstance→ populateBean

根据bean的生命周期,创建A对象,确定为普通bean,则调用getBean(beanName),方法中getSingleton为获取单例对象,但是传入的是一个lambda表达式参数,这个表达式只有该形参被调用getObject方法时才会被执行,这个表达式就是返回createBean方法,createBean方法中调用doCreateBean创建对象,创建时会调用createBeanInstance(反射创建对象发正在这个步骤中),这个方法根据实例化策略完成了了bean的实例化,最后将实例化完成的bean的属性完成配置.

如AB互相依赖,当创建A的过程走到createBeanInstance时此时A对象被实例化,但是B属性是NULL,A对象还是个半成品,这个时候将A类名和一个lambda表达式组装为键值对放入到三级缓存中去(清空二级缓存,此时初次创建就是空的;addSingletonFactories).

为A对象配置属性(获取A的属性名和value值,此处的value类型并不是B,而是一个运行时bean引用RuntimeReference,需要后续对值进行处理(如类型转等)),获取B的value时需要getBean,这是就是A的流程再走一遍创建B,同样走到将B的beanName和lambda放入三级缓存(addSingletonFactories).

当B对象配置属性A时,这个时候需要查询一二三级缓存,前两者没有,在三级缓存中存储有key为A,value为lamda表达式的map,此时需要调用lambda表达式参数的的getObject()方法让其执行(执行过程中使用的提前暴露对象,此时将半成品对象返回(也需要判断该对象是否有代理对象,有返回代理对象)),将半成品对象加入二级缓存,同时降三级缓存中对应的删除,这样就可以为B对象的属性赋值,复制完成后将B对象加入一级缓存,然后将三级缓存中的B对象删除,这个时候迭代回溯就可以将A对象的B属性赋值并放入一级缓存中并将二级缓存中A对象的半成品删除.

A对象创建完成,循环创建B对象的时候能在容器中查询到B对象,不在创建.

三个缓存对象中分别存储了什么对象?

一级缓存中放成品对象                         

二级缓存放半成品对象

三级缓存方lamda表达式

三级缓存对象的查找顺序?

一级→二级→三级

一级缓存能否解决循环依赖问题?

不能,一级缓存放的时成品对象,如果只有一级缓存,半成品和成品对象会放在一起,而半成品状态的对象不可以直接暴露给其他对象做引用,

二级缓存能否解决循环依赖问题?

可以解决部分,但是有限制条件,不能出现代理对象,从三级缓存中取出半成品对象放入二级缓存时,判断该类是否有代理对象,有的话就将代理对象放入二级缓存.

缓存放置时间与删除时间?

三级缓存:createBeanInstance之后

二级缓存:第一次从三级缓存中确定是代理对象还是普通对象,同时删除三级缓存中的对应的对象;getSingleton

一级缓存:生成完整对象后放入,GC回收

为什么要有三级缓存?

	三级缓存存在的意义是为了保证容器中同名对象只存在一个,且当一个对象需要代理的时候,我们需要先创建一个普通对象,这样我们在createbeanInstance创建对象的时候就可以判断当前类是否需要代理对象,将其存入三级缓存中的时候并不是存入的对象,而是一个lambda表达式,这个表达式被执行时会执行上述的判断,判断返回的是一个代理对象还是一个普通对象.

6.BeanFactory与FactoryBean有什么区别?

都是用于创建bean对象的,当使用前者创建对象的时候,必须严格遵循spring的bean生命周期,太复杂. 

如果想要简单的自定义个某个对象的创建,同时完成的对象想交给spring管理,就需要实现后者

	isSingleton:是否为单例

	getObejectType:获取返回对象类型                    

	getObject:自定义创建对象(new,反射,动态代理)  

7.spring中的设计模式?

单例模式:bean默认都是单例的

工厂模式:beanfactory

原型模式:指定作用域为prototype

观察者模式:listener,event,muticast

适配器模式:Adapter

装饰者模式:BeanWrapper

代理模式:动态代理

责任链模式:使用AOP的时候会先生合成一个拦截器链

委托者模式:delegate

8.spring的AOP的底层实现原理?

AOP的实现依赖的时动态代理.

AOP时IOC的一个扩展功能,spring在创建对象时会确定当前对象是否需要增强,BeanPostProcessor类的方法可以实现对类的增强

创建过程中确定advice,切面,切点,通过jdk或者cglib生成代理对象,advice织入切面通过代理对象调用实现对目标类的增强

执行方法调用的时候,会调用到省城的字节码文件中,直接找到DynamicAdvisoredInterceptor类中的Intercept方法,从此方法进行

4.根据定义好的通知来生成拦截器

5.从拦截器链中依次获取每一个通知进行执行.

9.spring的事务传播?

传播特性有7种:Required,Requires_new,nested,Support,Not_Support,Never,Mandatory



10.spring的事务是如何回滚的?spring的事务管理是如何实现的?

声明式事务,编程式事务

总:spring的事务是由AOP实现的,首先创建代理对象,按照AOP流程实现具体的操作逻辑,正常情况下要通过通知完成核心功能,但是事务是通过TransactionInterceptor实现的,然后调用invoke调用具体逻辑

分:

1.准备工作,解析各个方法上的事务属性,根据具体的属性判断是否开启新事务

2.当需要开启的时候,获取数据库连接,关闭自动提交功能,开启事务

3.执行sql

4.操作过程中试过失败了,会通过completeTransactionAfterThrowing来完成事务的回滚操作,回滚的具体逻辑是通过doRowBack方法实现的,实现的时候也是要获取连接对象(conn),通过连接对象来回滚

5.如果成功了,就会通过commitTransactionAfterReturning来完成事务的提交,提交的具体逻辑通过doCommit方法实现的,实现的时候也是通过连接对象来提交

6.当事务执行完毕,需要清除相关的事务信息(cleanTrasactionInfo)

11.单例模式的双重校验为什么要加volatile

java创建对象的过程可以分三个步骤:开辟内存空间,初始化内部属性,将对象地址赋值给引用,但是这个过程不是原子性的,会对指令进行重排,有可能对外暴露未初始化的对象发生空指针问题,使用volatile修饰属性,该关键字可以进制指令重排,从而避免上述情况

线程与锁

并行和并发有什么区别

并发就是指同一时刻CPU能够处理的任务数量,比如单核CPU通过切换时间片的方式,让两个任务交替执行,切换时间很短就会给人一种两个任务在同时执行的感觉,它的并发处理能力就是2;

并行就是指同一时刻,允许多个任务同时执行,在多核CPU中,同时执行任务的数量是由CPU的核心数量决定的.

并行和并发时JAVA并发编程中的一个概念,并行是指在多核CPU中同一个时刻同时可以执行多个线程的能力,在单核CPU中同时只能执行一个线程.并发是指同一个时刻CPU能够处理的任务数量,在单核CPU中,操作系统可以通过时间片切换机制实现同事执行多个任务.

线程切换

cpu可以简单的分成三个模块:

	PC(programcounter,存储程序指令)

	Registers:存储数据

	ALU:运算单元

	cache:存储线程执行记录

通过快速切换线程,实现单个核心并发执行多个任务

超线程是指多了一个PC和Registers,同时读取两个任务的指令,实现线程快速切换

线程池数量的如何定义

需要看该线程池执行的任务时什么类型,是否为CPU密集型,如果是还要确定需要占用的CPU百分比,通过设置初始值进行压测逐步调整,比如某个任务整个时间线cpu计算占用为四分之一,想要占用一个单核cpu百分之百就需要四个同样的任务同时执行才能满足条件.

CPU的三级缓存

CPU向本地缓存和内存中取数据速率差100倍,为了避免内存限制CPU设置了三级缓存,单核独有一二级缓存,多核共享三级缓存.每次向内存中读取数据,会在三级缓存中留下备份,且取数据的时候会多取一些,减少取数据次数提升效率,每次取数据为64个字节.

DCL锁

某些方法需要加锁,但是在方法上加锁,锁的粒度粗,消耗大.就会局部加锁,如创建单例对象的懒汉模式,就只在创建对象处枷锁,但是也有问题,就是在一个线程判断当前对象为空的时候停止,另一个线程也来判断当前对象是否为空,然后请求锁并创建对象,最后释放锁,这个时候第一个线程再次请求锁并创建对象,这种情况就不是单例对象了.所以为了解决这个种情况就有了DCL(double check lock),也就是检查两次再加锁,第一次判断是否为空,加锁后再次检查是否为空,然后再创建对象.外层的判断是为了避免多个线程同时取创建对象时同时去申请锁,消耗过大,但是判断的消耗却很低,只要有一个线程创建了对象,后面的线程就不能再去申请锁了.

但是还是会有一个问题,当一个线程在创建对象的时候,因为创建对象可以简单的分为三步开辟内存空间初始化对象,为对象属性赋值,将指针指向对象.当另一个线程在这个线程完成初始化时初次判断当前对象是否为空,而且因为CPU对创建对象的指令进行了重排,导致二三步骤反转,就会得到否的答案,从而去访问并未完全创建完成的对象.此处的锁并没有解决并发编程的原子性,解决了可见性,有序性.

解决:硬件级别,在不影响单线程最终结果的情况下可以更换指令运行顺序

锁的含义

sychronized(可以是类或者属性){}

Java中任何对象都可以当作锁使用,对象在内存中的样子:

	对象头(12bytes):

		markword(标记字):8bytes(存储着锁的信息,GC信息,hashcode值)

		classpointer(类型指针):4bytes

	实例数据:存储对象实例内容 

	对齐:保证这个对象在内存中占用大小能被8整除

当一个对象被当作锁使用的时候,它的头就会记录锁的信息

CAS(乐观锁)

cas是乐观锁的一种实现,更改一个数据在返回前判断是否与取出的数据是否相同,相同就修改,不同就重新获取数据再修改.读多写少乐观锁;写多读少悲观锁.

可能存在ABA问题,就是指确认数据时发现相同,但在此之前发生了改变,又被改了回来.解决方法为加上版本号,每次修改都更改版本号,对比值也对比版本号,当不在乎版本号的时候就可以将版本号设置成布尔类型

锁升级

JDK 1.6之前，synchronized 还是一个重量级锁，是一个效率比较低下的锁，但是在JDK 1.6后，Jvm为了提高锁的获取与释放效率进行了优化，引入了 偏向锁 和 轻量级锁 ，从此以后锁有四种状态:无锁,偏向锁,轻量级锁,重量级锁,锁状态只能升级，不能降级 .

偏向锁

	初次执行到synchronized代码块的时候，锁对象变成偏向锁 ,执行完同步代码块后，线程并不会主动释放偏向锁。当第二次到达同步代码块时，线程会判断此时持有锁的线程是否就是自己（持有锁的线程ID也在对象头里），如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。 

轻量级锁

	轻量级锁是指当锁是偏向锁的时候，发生锁竞争,所谓竞争就是指一个线程持有锁,另外的线程无法获取锁，此时偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，线程不会阻塞，从而提高性能。 如果多个线程用一个锁，但是没有发生锁竞争，或者发生了很轻微的锁竞争，那么synchronized就用轻量级锁，允许短时间的忙等现象。这是一种折衷的想法，短时间的忙等，换取线程在用户态和内核态之间切换的开销。 

	轻量级锁的获取主要由两种情况： ① 当关闭偏向锁功能时； ② 由于多个线程竞争偏向锁导致偏向锁升级为轻量级锁。 

重量级锁

	如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为重量级锁 .重量级锁是指当有一个线程获取锁之后，其余所有等待获取该锁的线程都会处于阻塞状态.重量级锁就是将所有的控制权交给操作系统,由操作系统负责线程间的调度.

创建线程的方式

继承Thread类,重写run方法

实现runable接口,重写run方法.创建的时候需要new出实现类对象,传入到new Thread()中

创建类继承TimerTask，重写run()方法 

实现Callable接口结合FutureTask,Callable的call方法可以有返回值,且可以抛出异常;使用线程池获取线程,实现类对象为c,pool(ExcutorService,线程池).submit(c),返回值为Future对象,get方法可以获取返回值;无参数可以用pool.excutor(c)直接执行任务

使用线程池,如用Executor框架继承Thread类创建

四种线程池

线程池的顶级接口时Excutor,严格来讲它并不是一个线程池,而是一个线程的执行器,真正的线程池接口是ExcutorService.

newCachedThreadPool

	根据需要创建线程的线程池,线程数随机,取决于当时处理器的情况,线程空闲时间超过60秒就会被杀死.长时间空闲线程池不会占用空间

newFixedThreadPool

	固定大小可重用的线程池,参数为线程数.新任务进来无可用线程会进入队列等待,执行失败会有新线程替它执行后续任务.线程未显关闭,线程池就会存在.

newScheduledThreadPool

	可执行延迟或者定时任务的线程池

newSingleThreadExecutor

	单线程池,这个线程池就可以在线程死后或者发生异常时重新启动一个新的线程代替执行任务.

停止一个线程

执行完任务自动终止

调用给stop,强行终止(已作废,不推荐)

调用interrupt中断

notify()和notifyAll()有什么区别？

锁池:线程被唤醒或者调用了start的线程在竞争锁的时候就处于锁池

等待池:线程调用了wait方法,就进入等待池

notify是对notifyall的优化,但是有精确的应用场景,因为它可能导致死锁

notify()只唤醒一个正在等待的线程，当该线程执行完以后施放该对象的锁，而没有再次执行notify()方法， 则其它正在等待的线程 则一直处于等待状态 ,就处于死锁状态

notifyall会唤醒所有在等待的线程,就是将所有等待池的线程都移到锁池中竞争锁

线程的生命周期和状态

状态:

	新生状态:线程初次创建

	就绪状态:新建线程后调用start方法,线程进入就绪状态

	运行状态:就绪状态获取资源并且被分配任务

	阻塞状态:线程被挂起,或者需要执行耗时的IO操作,如果调用了sleep()、 suspend()、 wait() 等方法

	死亡状态:线程调用 stop()方法、destory()方法或 run()方法执行结束后 

生命周期:

ThreadLocal会造成内存泄漏吗?

Threadlocal是用来保证线程安全性的工具,每个线程都成员变量中维护着一个key-value形式的ThreadLocalMap,线程在执行任务时会开辟一块私有的内存空间,获取到的数据会在ThreadlocalMap中保存一份备份,这样就只需要操作副本就可以了,避免了多线程间的资源竞争.ThreadlocalMap中的key是指向ThreadLocal的弱引用,允许这种引用存在的情况下被回收,造成key为null.从而导致这块内存永远无法被访问,如果是单线程的调用,线程被回收后他的恒源变量ThreadlocalMap也一起被回收了就不会造成内存泄漏,但是我们一般使用线程池创建线程,线程存在复用的情况,虽然在我们进行数据读写的时候默认ThreadLocalMap中一些key为null的entry,但是还是无法完全避免内存泄露.

解决:

	1.每次使用完ThreadLocal以后主动调用remove方法(推荐)

	2,把TreadLocal设置为全局变量,扩大它的作用域使它不会被gc回收(不用的时候也占内存,会造成内存溢出)

回答:错误的使用ThreadLocal会造成内存泄漏,ThreadLocalMap中的key是指向ThreadLoca的弱引用,它允许在这种引用存在的情况下ThreadLocal被回收,这样key就会变成null,这块内存永远无法访问,导致内存泄漏.

如何预防死锁

死锁:四个必要条件

	1.互斥条件:同一时间只能有一个线程获取资源

	2.不可剥夺条件:一个线程已经占有资源,在释放之前不会被其他线程抢占

	3.请求保持条件:线程等待中不释放资源

	4.循环等待条件:多个线程等待对方释放资源

预防:打破三个条件之一即可(互斥除外,因为是资源使用的必要条件)

	不可剥夺:一个线程无法获取到需要的所有资源进入等待状态,并释放资源

	请求保持:静态分配开始执行前必须获取所有资源;动态分配,申请资源时不占用系统资源

	循环等待:根据优先级获取资源,避免产生资源争夺的闭环.

什么是守护线程

Java中线程分为用户线程和守护线程

任何一个守护线程都是JVM中所有非守护线程的保姆;任何一个非守护线程没有结束,守护线程就全部工作,只有最后一个非守护线程结束时,守护线程随着JVM一同结束工作.

注意: 

	Thread.setDaemon(true)设置守护线程,必须在线程调用start之前设置,否则抛异常

	在守护线程中产生的新线程也是守护县旧城

	并不是所有的应用都可以分配给Daemon来进行读写操作或者计算逻辑,可能导致数据不一致

为什么使用线程池

降低资源消耗,线程复用,不需要频繁创建线程

提高响应速度,任务到达直接取出线程执行

提高线程的可管理性.

线程的sleep,wait,join,yield如何使用

sleep的作用是让当前线程进入休眠，进入“堵塞状态”，放弃占有的CPU时间片，让给其他线程使用,且调用过程中如果有异常(interrupteException)会抛出.

wait方法作用是让当前线程进入等待,且只能在sychronized块中调用,线程会释放资源,进入等待池,直到等待到期或被notify和notifyall唤醒

jion是指当一个任务需要两个线程协作,线程A执行任务时B线程调用join,A线程就会进入阻塞状态,直到B线程执行完成,A线程继续执行任务

yield是指将当前线程恢复到就绪状态,这样这个线程会与锁池中的线程重新整抢资源.此时释放的是系统资源,并不会释放锁资源

什么是可重入锁,它的作用是什么?

简单来说，就是在运行的某个函数或者代码，因为抢占资源或者中断等原因导致函数或者代码的运行中断，

等待中断程序执行结束后，重新进入到这个函数或者代码中运行，并且运行结果不会受到影响，那么这个函数或者代码就是可重入的。

而可重入锁，简单来说就是一个线程如果抢占到了互斥锁资源，在锁释放之前再去竞争同一把锁的时候，不需要等待，只需要记录重入次数。

在多线程并发编程里面，绝大部分锁都是可重入的，比如Synchronized、ReentrantLock等，但是也有不支持重入的锁，比如JDK8里面提供的读写锁StampedLock。

锁的可重入性，主要解决的问题是避免线程死锁的问题。

因为一个已经获得同步锁X的线程，在释放锁X之前再去竞争锁X的时候，相当于会出现自己要等待自己释放锁，这很显然是无法成立的。

AQS



Redis

说说你对redis的理解?

redis是一个分布式缓存中间件,是一个基于内存的key-value形式的nosql数据库.

它提供了5种常用数据类型:string,list,hash,set,zset;不同的结构可以解决不同的应用场景.由于它是基于内存实现的存储,所以它的IO性能非常高,实际开发中经常用于分布式缓存,用于降低数据库的压力,而且它是一个非关系型的数据库,不存在表与表的关联查询的问题,所以它可以很好的提升应用程序的IO效率.

作为企业级开发来说它又提供了主从复制+哨兵提升了部署可靠性,还提供了RDB和AOF的数据持久化方式,提升了数据的可靠性.

RDB与AOF的不同?

redis的持久化是通过fork()方法创建一个子进程,将当前父进程内存中的数据复制到子进程的内存中去,然后由子进程写入到临时文件中,持久化过程结束后再将这个临时文件替换掉上次的快照文件

RDB是redis的默认持久化方式,按照一定的周期策略将内存中的数据以快照的形式保存到硬盘的二进制文件,产生的文件名未dump.rdb,配置文件种的savec参数定义周期

AOF的保存方式是将每次收到一个写命令都记录下来,写在文件最后,当redis需要恢复数据时将命令重新执行一遍

redis是单线程还是多线程?

redis6.0之前 单线程是指其网络IO和键值读写是由一个线程完成的.

redis6.0之后引入的多线程是指网络请求过程中使用了多线程,而键值对的读写是单线程完成的,所以Redis依然是并发安全的.也就是指只有网络请求和数据操作是单线程的,其他的如持久化,集群数据同步等是多线程完成的

redis单线程为啥还那么快?

命令基于纯内存操作

单线程无线程切换消耗

基于IO多路复用机制提升IO效率

高效的数据存储结构,全局hash表.

redis底层数据是如何用跳表来存储的?

有序集合会根据分值排序,为了提升链表的查询效率,使用跳表来优化,就是将每两个元素结合生成一个冗余的索引,取分值小的那个,元素多的时候还可以继续增加冗余索引,但是取的是上一层索引的元素,这样在查找的时候先从最上层索引确定返回就可以排除掉一半的元素,逐层判断就可以提升查询的效率

redis的key过期了为什么没有释放内存?

有可能是由于修改key的时候未重新设置过期时间.

redis对于一些过期的key有两种处理策略:

	惰性删除:当读写一个已经过期的key的时候会触发惰性删除,删除一些过期的key

	定时删除:惰性删除并不能保证一些已经长久没有使用的key被及时删除,所以会定期(默认每100ms)主动淘汰一批已经过期的key,这里只是部分过期key,所以可能会出现部分key已经过期但是没有被删除的情况,倒是内存没释放.

什么是redis的缓存雪崩,穿透,击穿?

缓存雪崩是指大量的key在同一时间失效,导致大量的请求全都打到了数据库上,造成数据库挂掉.

解决方法:

	就是在设置失效时间的时候不要设置相同的失效时间,尽可能的散列设置失效时间;

	redis都是集群部署,将热点key平均的部署在不同的节点上;

缓存穿透是查询数据库和缓存中都不存在的数据,当这种查询过多的时候,缓存并没有拦截这种查询,导致全都达到了数据库上,服务挂掉.

解决方法:

	当从数据库中查询时,不观察到的数据是否为空都将它设置到缓存中去

	ip封禁

	查询前对参数合法性进行校验,不合法直接返回空

	布隆过滤器

缓存击穿是指热点数据失效后,大量的请求直接到了数据库导致服务挂掉

解决:	

	设置热点数据的key永不过期(不推荐)

	分布式锁,当热点数据失效的时候,需要取数据库查询时加锁,其他没有获取锁的线程进入阻塞状态,查询到数据将它设置到缓存中取,其他线程就可以从缓存中查询数据了

分布式锁

setnx:该命令类似于set命令都是向redis中添加键值对,但不同的是,该命令只有在key不存在的时候才能设置成功,而不是像set命令那样会将值覆盖掉.基于这样的原理就可以将通过redis实现分布式锁,获取锁的过程就是向redis中设值的过程,比如同一件商品减库存的操作有并发问题,就将商品ID最为Key,进行设值,设值成功的线程才能进行减库存操作.

    	// 模拟多线程抢购减库存操作
            // 跟去setNx()原理使用redis实现分布式锁,并调用setIfAbsent方法将设值与设置超时放一起,保持原子性
            String uuid = UUID.randomUUID().toString();
            Boolean aTrue = stringRedisTemplate.opsForValue().setIfAbsent("Test:Id", uuid, 10, TimeUnit.SECONDS);
    	
            // 使用try-finally释放锁
            try {
                // 加锁成功
                if (aTrue){
                    System.out.println("减库存");
                }else {
                    // 加锁失败
                    System.out.println("减库存失败");
                }
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                // 由于设置了失效时间,如果再上述代码在线程执行中超时,锁失效,同时新线程加锁成功,如果此时删除锁就是把别的线程的锁删除了,根据uuid验证是否为自己的锁
                if (uuid.equals(stringRedisTemplate.opsForValue().get("Test:Id"))){
                    // 如果锁在判断完成删除前失效了,且其他线程加了锁,又会出现删除其他线程的锁的情况
                    // 保证原子性:增加个守护线程为锁续命
                    stringRedisTemplate.delete("Test:Id");
                }
            }

由于redis都是集群布置的,redis时AP设计理念,更多的是保证可用性,有可能发生,主节点加锁成功,为同步前宕机,导致锁丢失的问题,Redlock方法可以解决这些问题

Redlock采用的是zookeeper的理念,集群间等价无主从关系,设置锁需要向每一个节点加锁,只有超过半数的节点加锁成功了才算加锁成功,这样在其他线程加同一把锁的时候就不可能加锁超过半数.

问题:如果持久化方案是aof的周期持久化,就会出现如果持久化时加锁成功,但是宕机重启了,这个时候又一个线程加锁就能超过半数,这样就只能采用写一条持久化一条的策略降低了性能

布隆过滤器

布隆过滤器就是维护了一个长数组,数组初始数据存入的都是0,向过滤器存入数据时会先经过几个hash函数计算,得出数值后根据数值将数组中对应位置的0改为1,比如taobao这个词hash结果为1,4,7那么这三个索引位置处的0改为1,天猫hash结果为2,4,9;那么当查询jingdong时,hash结果为1,3,9;只有1,9位置为1,3为0那么jingdong不存在,但是这样的逻辑时允许误算的,假如pdd为1,7,9这三个位置均为1,但是数据并未村如果返回的确实true;
